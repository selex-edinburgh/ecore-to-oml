operation getPathFromNsURI() {
    var eResource = M2.getResource();
    var eObject = eResource.getContents.first;
    return eObject.eClass.ePackage.getPathFromNsURI();
}

operation getEResource() {
    var eResource = M2.getResource();
    return eResource;
}

operation getModelName(){
    var eResource = M2.getResource();
    var path = eResource.getURI.toString;
    var startIndex = path.lastIndexOf("/");
    var endIndex = path.lastIndexOf(".");
    var name = path.substring(startIndex + 1, endIndex);
    name = name.replace("\\.", "");
    return name;
}

operation M2!ecore::EObject getName(){
    var name = (self.eClass.getEStructuralFeature("name") <> null)? self.name : self.eClass.name.toLowerCase;
    return name;
}

operation M1!ecore::EPackage getPathFromNsURI() {
    var uri = self.nsURI;
    uri = uri.replace("http://", "");
    uri = uri.replace("https://", "");
    return uri;
}

operation M1!ecore::EClass getParentClasses() {
    var parentNames = self.getESuperTypes.collect(s | s.name);
    var temp = parentNames.concat(", ");
    var names = (temp.length > 0)? ", " + temp : names;  
    return names;
}

operation M1!ecore::EEnum getLiterals() {
    var literals = "\"" + self.getELiterals.concat("\",\n\"") + "\"";   
    return literals;
}

operation M2!ecore::EStructuralFeature isSet(eObject) {
	var isSet = eObject.eIsSet(self); 
    return isSet;
}

operation M1!ecore::EObject isSet(eStructuralFeature) {
    var isSet = self.eIsSet(eStructuralFeature); 
    return isSet;
}

operation M1!ecore::EAttribute getXsdType(){
    var type = null;
    if (self.eType.name.equals("EString")) {
       type = "xsd:string";
    } else if (self.eType.name.equals("EBoolean") or self.eType.name.equals("EBooleanObject")) {
       type = "xsd:boolean";
    } else if (self.eType.name.equals("EByte") or self.eType.name.equals("EByteObject")) {
       type = "xsd:byte";
    } else if (self.eType.name.equals("EChar") or self.eType.name.equals("ECharacterObject")) {
       type = "xsd:string";
    } else if (self.eType.name.equals("EDouble") or self.eType.name.equals("EDoubleObject")) {
       type = "xsd:double";
    } else if (self.eType.name.equals("EFloat") or self.eType.name.equals("EFloatObject")) {
       type = "xsd:float";
    } else if (self.eType.name.equals("EInt") or self.eType.name.equals("EIntegerObject")) {
       type = "xsd:integer";
    } else if (self.eType.name.equals("ELong") or self.eType.name.equals("ELongObject")) {
       type = "xsd:long";
    } else if (self.eType.name.equals("EShort") or self.eType.name.equals("EShortObject")) {
       type = "xsd:short";
    } else if (self.eType.isTypeOf(M1!ecore::EEnum)) {
       type = self.eType.name;
    } 
//	EBoolean
//	EByte
//	EChar
//	EDouble
//	EFloat
//	EInt
//	ELong
//	EShort
//	EJavaObject
//	EJavaClass
//	EBooleanObject
//	EByteObject
//	ECharacterObject
//	EDoubleObject
//	EFloatObject
//	EIntegerObject
//	ELongObject
//	EShortObject
//	EByteArray
//	
//	EDate
//	EBigInteger
//	EBigDecimal
//	EResource
//	EResourceSet
//	EFeatureMap
//	EFeatureMapEntry
//	EEnumerator
//	EEList
//	ETreeIterator
    return type;
}

//anyURI, base64Binary, boolean, date, dateTime, decimal, double, duration, float, hexBinary, gDay, gMonth, gMonthDay, gYear, gYearMonth, NOTATION, QName, string, and time
//byte    Used to define a signed 8-bit integer.
//decimal Used to define a decimal value.
//int Used to define a signed 32-bit integer.
//integer Used to define an integer value.
//long    Used to define a signed 64-bit integer.
//negativeInteger Used to define an integer containing only negative values (..,-2,-1).
//nonNegativeInteger  Used to define an integer containing only non-negative values (0,1,2,..).
//nonPositiveInteger  Used to define an integer containing only non-positive values (..,-2,-1,0).
//positiveInteger Used to define an integer containing only positive values (1,2,..).
//short   Used to define a signed 16-bit integer.
//unsignedLong    Used to define an unsigned 64-bit integer.
//unsignedInt Used to define an unsigned 32-bit integer.
//unsignedShort   Used to define an unsigned 16-bit integer.
//unsignedByte    Used to define an unsigned 8-bit integer.